
/*
 * SVR 4.2 STREAMS YHTP - Release 1.0 
 *
 * Copyright 1994 NET612 Computer Department of NUDT 
 * All Rights Reserved. 
 */

#define STRNET

#include <util/types.h>
#include <util/param.h>
#include <svc/systm.h>
#include <io/stream.h>
#include <net/yhtpip/protosw.h>
#include <net/transport/socket.h>
#include <net/transport/sockio.h>
#include <svc/errno.h>
#include <io/stropts.h>
#include <io/strlog.h>
#include <io/log/log.h>
#include <net/yhtpip/yhif.h>
#include <net/yhtpip/af.h>
#include <net/yhtpip/yhin.h>
#include <net/yhtpip/yhin_var.h>
#include <net/yhtpip/yhroute.h>

#ifdef SYSV
#include <util/cmn_err.h>
#endif SYSV

#include <net/yhtpip/yhip_str.h>

int             yhrttrash;	/* routes not in table but not freed */
struct in_addr  yhwildcard;	/* zero valued cookie for yhwildcard searches */
int             yhrthashsize = RTHASHSIZ;	/* for netstat, etc. */
int             yhinet_netmatch();
struct rtstat   yhrtstat;

extern struct ip_provider *
yhprov_withaddr(), *yhprov_withnet(), *yhloopprov;

#define satosin(sa)	((struct sockaddr_in *) (sa))

/*
 * Packet routing routines. 
 */
yhrtalloc(ro, switchflag)
	register struct route *ro;
{
	register struct rtentry *rt;
	register mblk_t *bp;
	register u_long hash;
	struct in_addr  dst;
	int             (*match) (), doinghost;
	struct afhash   h;
	mblk_t        **table;

	STRLOG(IPM_ID, 0, 9, SL_TRACE, "yhrtalloc to %x", 
	       satosin(&ro->ro_dst)->sin_addr.s_addr);
	dst.s_addr = satosin(&ro->ro_dst)->sin_addr.s_addr;
	if (ro->ro_rt && RT(ro->ro_rt)->rt_prov
	    && (RT(ro->ro_rt)->rt_flags & RTF_UP))
		return (RT_OK);	/* XXX */
	yhinet_hash(dst, &h);
	match = yhinet_netmatch;
	hash = h.afh_hosthash;
	table = yhrthost;
	doinghost = 1;
again:
	for (bp = table[RTHASHMOD(hash)]; bp; bp = bp->b_cont) {
		rt = RT(bp);
		if (rt->rt_hash != hash)
			continue;
		if (rt->rt_prov == 0) {
#ifdef u3b2
			cmn_err(CE_WARN, "yhrtalloc: null prov");
#else
			printf ("yhrtalloc: null prov");
#endif
			continue;
		}
		if ((rt->rt_flags & RTF_UP) == 0 ||
		    (rt->rt_prov->if_flags & IFF_UP) == 0)
			continue;
		if (doinghost) {
			if (satosin(&rt->rt_dst)->sin_addr.s_addr != dst.s_addr)
				continue;
		} else {
			if (!(*match) (satosin(&rt->rt_dst)->sin_addr, dst))
				continue;
		}
		if (dst.s_addr == yhwildcard.s_addr)
			yhrtstat.rts_wildcard++;
		ro->ro_rt = bp;
#ifdef SLIP
		if (rt->rt_flags & RTF_SWITCHED)
			return (yhrtswitch(ro, switchflag));	/* switched SLIP */
#endif /* SLIP */
		rt->rt_refcnt++;
		return (RT_OK);
	}
	if (doinghost) {
		doinghost = 0;
		hash = h.afh_nethash, table = yhrtnet;
		goto again;
	}
	/*
	 * Check for yhwildcard gateway, by convention network 0. 
	 */
	if (dst.s_addr != yhwildcard.s_addr) {
		dst.s_addr = yhwildcard.s_addr, hash = 0;
		goto again;
	}
	yhrtstat.rts_unreach++;
	return (RT_FAIL);
}

yhrtfree(bp)
	mblk_t         *bp;
{
	struct rtentry *rt = RT(bp);

	if (rt == 0)
#ifdef u3b2
		cmn_err(CE_PANIC, "yhrtfree");
#else
		panic ("yhrtfree");
#endif
	rt->rt_refcnt--;
	if (rt->rt_refcnt == 0) {
#ifdef SLIP
		if (rt->rt_flags & RTF_SWITCHED)
			yhrtunswitch(rt);	/* switched SLIP */
		else
#endif /* SLIP */
			if ((rt->rt_flags & RTF_UP) == 0) {
			yhrttrash--;
			(void) freeb(bp);
		}
	}
}


/*
 * Force a routing table entry to the specified destination to go through the
 * given gateway. Normally called as a result of a routing redirect message
 * from the network layer. 
 *
 */
yhrtredirect(dst, gateway, flags, src)
	struct in_addr  dst, gateway, src;
	int             flags;
{
	struct route    ro;
	register struct rtentry *rt;
	register mblk_t *bp;

	/* verify the gateway is directly reachable */
	if (yhprov_withnet(gateway) == 0) {
		yhrtstat.rts_badredirect++;
		return;
	}
	satosin(&ro.ro_dst)->sin_addr.s_addr = dst.s_addr;
	ro.ro_rt = 0;
	yhrtalloc(&ro, 0);	/* no dialing */
	bp = ro.ro_rt;
	rt = RT(bp);

	/*
	 * If the redirect isn't from our current router for this dst, it's
	 * either old or wrong.  If it redirects us to ourselves, we have a
	 * routing loop, perhaps as a result of an interface going down
	 * recently. 
	 */
	if ((bp && src.s_addr != satosin(&rt->rt_gateway)->sin_addr.s_addr)
	    || yhprov_withaddr(gateway)) {
		yhrtstat.rts_badredirect++;
		if (bp)
			yhrtfree(bp);
		return;
	}
	/*
	 * Create a new entry if we just got back a yhwildcard entry or the the
	 * lookup failed.  This is necessary for hosts which use routing
	 * redirects generated by smart gateways to dynamically build the
	 * routing tables. 
	 */
	if (bp &&
	    yhinet_netmatch(yhwildcard, satosin(&rt->rt_dst)->sin_addr)) {
		yhrtfree(bp);
		bp = 0;
	}
	if (bp == 0) {
		yhrtinit(dst, gateway, (int) SIOCADDRT,
		       (flags & RTF_HOST) | RTF_GATEWAY | RTF_DYNAMIC);
		yhrtstat.rts_dynamic++;
		return;
	}
	/*
	 * Don't listen to the redirect if it's for a route to an interface. 
	 */
	if (rt->rt_flags & RTF_GATEWAY) {
		if (((rt->rt_flags & RTF_HOST) == 0) && (flags & RTF_HOST)) {
			/*
			 * Changing from route to net => route to host.
			 * Create new route, rather than smashing route to
			 * net. 
			 */
			yhrtinit(dst, gateway, (int) SIOCADDRT,
			       flags | RTF_DYNAMIC);
			yhrtstat.rts_dynamic++;
		} else {
			/*
			 * Smash the current notion of the gateway to this
			 * destination. 
			 */
			satosin(&rt->rt_gateway)->sin_addr = gateway;
		}
		rt->rt_flags |= RTF_MODIFIED;
		yhrtstat.rts_newgateway++;
	} else
		yhrtstat.rts_badredirect++;
	yhrtfree(bp);
}

/*
 * Routing table ioctl interface. 
 */
yhrtioctl(cmd, data)
	int             cmd;
	mblk_t         *data;
{

	if (cmd != SIOCADDRT && cmd != SIOCDELRT)
		return (EINVAL);
	return (yhrtrequest(cmd, data));
}

/*
 * Carry out a request to change the routing table.  Called by interfaces at
 * boot time to make their ``local routes'' known, for ioctl's, and as the
 * result of routing redirects. 
 */
yhrtrequest(req, bp)
	mblk_t         *bp;
	int             req;
{
	register struct rtentry *entry = RT(bp);
	register mblk_t *m, **mprev;
	mblk_t        **mfirst;
	register struct rtentry *rt;
	struct afhash   h;
	int             error = 0;
	u_long          hash;
	struct ip_provider *prov = 0, *yhprov_withdstaddr();
	extern int      yhin_interfaces;

	yhinet_hash(satosin(&entry->rt_dst)->sin_addr, &h);
	if (entry->rt_flags & RTF_HOST) {
		hash = h.afh_hosthash;
		mprev = &yhrthost[RTHASHMOD(hash)];
	} else {
		hash = h.afh_nethash;
		mprev = &yhrtnet[RTHASHMOD(hash)];
	}
	for (mfirst = mprev; m = *mprev; mprev = &m->b_cont) {
		rt = RT(m);
		if (rt->rt_hash != hash)
			continue;
		if (entry->rt_flags & RTF_HOST) {
			if (satosin(&rt->rt_dst)->sin_addr.s_addr != 
			    satosin(&entry->rt_dst)->sin_addr.s_addr)
				continue;
		} else {
			if (yhinet_netmatch(satosin(&rt->rt_dst)->sin_addr, 
					  satosin(&entry->rt_dst)->sin_addr) 
			    == 0)
				continue;
		}
		if (satosin(&rt->rt_gateway)->sin_addr.s_addr == 
		    satosin(&entry->rt_gateway)->sin_addr.s_addr)
			break;
	}
	switch (req) {

	case SIOCDELRT:
		if (m == 0) {
			error = ESRCH;
			goto bad;
		}
		/* dont inadvertently delete switched routes */
		if (rt->rt_flags & RTF_SWITCHED
		    && !(rt->rt_flags & (RTF_SLAVE | RTF_TOSWITCH))) {
			if (!(entry->rt_flags & RTF_SWITCHED)) {
				error = EINVAL;
				goto bad;
			}
			yhin_interfaces--;
		}
		*mprev = m->b_cont;
		if (rt->rt_refcnt > 0) {
			rt->rt_flags &= ~RTF_UP;
			yhrttrash++;
			m->b_cont = 0;
		} else
			(void) freeb(m);
		break;

	case SIOCADDRT:
		if (m) {
			error = EEXIST;
			goto bad;
		}
		/* first check for switched route, and use local as dummy */
		if (entry->rt_flags & RTF_SWITCHED) {
			prov = yhloopprov;
			yhin_interfaces++;
		}
		/*
		 * If we are adding a route to an interface, and the
		 * interface is a pt to pt link we should search for the
		 * destination as our clue to the interface.  Otherwise we
		 * can use the local address (below). 
		 */
		if (prov == 0 && (entry->rt_flags & RTF_GATEWAY) == 0
		    && (entry->rt_flags & RTF_HOST))
			prov = yhprov_withdstaddr(satosin(&entry->rt_dst)->sin_addr);
		if (prov == 0 && (entry->rt_flags & RTF_GATEWAY) == 0)
			prov = yhprov_withaddr(satosin(&entry->rt_gateway)->sin_addr);
		if (prov == 0)
			prov = yhprov_withnet(satosin(&entry->rt_gateway)->sin_addr);
		if (prov == 0) {
			error = ENETUNREACH;
			goto bad;
		}
		m = allocb(sizeof(struct rtentry), BPRI_MED);
		if (m == 0) {
			error = ENOSR;
			goto bad;
		}
		m->b_cont = *mfirst;
		*mfirst = m;
		m->b_wptr += sizeof(struct rtentry);
		rt = RT(m);
		rt->rt_hash = hash;
		rt->rt_dst = entry->rt_dst;
		rt->rt_gateway = entry->rt_gateway;
		rt->rt_flags = RTF_UP |
			(entry->rt_flags & (RTF_USERMASK | RTF_TOSWITCH | RTF_DYNAMIC));
		rt->rt_refcnt = 0;
		rt->rt_use = 0;
		rt->rt_prov = prov;
		break;
	default:
		error = EINVAL;
		break;
	}
bad:
	return (error);
}

/*
 * Set up a routing table entry, normally for an interface. 
 */
yhrtinit(dst, gateway, cmd, flags)
	struct in_addr  dst, gateway;
	int             cmd, flags;
{
	mblk_t         *bp;
	struct rtentry *route;

	bp = allocb(sizeof(struct rtentry), BPRI_HI);
	if (bp == 0) {
		return;
	}
	bp->b_wptr += sizeof(struct rtentry);
	route = RT(bp);
	bzero((caddr_t) route, sizeof(route));
	satosin(&route->rt_dst)->sin_addr = dst;
	satosin(&route->rt_gateway)->sin_addr = gateway;
	route->rt_flags = flags;
	(void) yhrtrequest(cmd, bp);
	(void) freeb(bp);
}

/*
 * flush all routing table entries for an interface being detached 
 */
yhrtdetach(prov)
	struct ip_provider *prov;
{
	register mblk_t *m, *mnext;
	register mblk_t **table;
	register ushort i, j;

	for (j = 0, table = yhrthost; j < 2; j++, table = yhrtnet) {
		for (i = 0; i < RTHASHSIZ; i++) {
			if (table[i] == NULL)
				continue;
			for (mnext = table[i]; m = mnext;) {
				mnext = m->b_cont;
				if (RT(m)->rt_prov == prov)
					(void) yhrtrequest(SIOCDELRT, m);
			}
		}
	}
}

