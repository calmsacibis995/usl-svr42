/*	Copyright (c) 1990, 1991, 1992 UNIX System Laboratories, Inc.	*/
/*	Copyright (c) 1984, 1985, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF     	*/
/*	UNIX System Laboratories, Inc.                     	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)mailx:is.c	1.4.2.4"
#ident "@(#)is.c	1.11 'attmail mail(1) command'"
#include "rcv.h"
#include <pwd.h>

static int isit ARGS((char *lp, int type));

/*
 * isheader(lp, ctf) - check if lp is header line and return type
 *	lp	-> 	pointer to line
 *	ctfp	->	continuation flag (should be FALSE the first time
 *			isheader() is called on a message.  isheader() sets
 *			it for the remaining calls to that message)
 * returns
 *	FALSE	->	not header line
 *	H_*     ->	type of header line found.
 */
int
isheader(lp, ctfp)
char	*lp;
int	*ctfp;
{
	register char	*p, *q;
	register int	i;

	p = lp;
	while((*p) && (*p != '\n') && (isspace(*p))) {
		p++;
	}
	if((*p == NULL) || (*p == '\n')) {
		/* blank line */
		return (FALSE);
	}

	if ((*ctfp) && ((*lp == ' ') || (*lp == '\t'))) {
		return(H_CONT);
	}

	*ctfp = FALSE;
	for (i = 1; i < H_CONT; i++) {
		if (!isit(lp, i)) {
			continue;
		}
		if ((i == H_FROM) || (i == H_FROM1)) {
			/* From and >From must be case sensitive matches. */
			if (strncmp(lp, header[i].tag, strlen(header[i].tag)) != 0)
				return (FALSE);
			/*
			 * Should NEVER get 'From ' or '>From ' line on stdin
			 * if invoked as mail (rather than rmail) since
			 * 'From ' and/or '>From ' lines are generated by
			 * program itself. Therefore, if it DOES match and
			 * ismail == TRUE, it must be part of the content.
			 */
			if (sending && ismail) {
				return (FALSE);
			}
		}
		*ctfp = TRUE;
		return (i);
	}
	/*
	 * Check if name: value pair
 	 */
	if ((p = strpbrk(lp, ":")) != NULL ) {
		for(q = lp; q < p; q++)  {
			if ( (!isalnum(*q)) && (*q != '-') && (*q != '>'))  {
				return(FALSE);
			}
		}
		/* the : must be followed by white-space or the end of the line */
		q++;
		if (*q && (*q != ' ') && (*q != '\t') && (*q != '\n') && (*q != '\r'))
			return(FALSE);
		*ctfp = TRUE;
		return(H_NAMEVALUE);
	}
	return(FALSE);
}

/*
 * isit(lp, type) -- case independent match of "name" portion of 
 *		"name: value" pair
 *	lp	->	pointer to line to check
 *	typehdr	->	type of header line to match
 * returns
 *	TRUE	-> 	lp matches header type (case independent)
 *	FALSE	->	no match
 */
static int
isit(lp, typehdr)
register char 	*lp;
register int	typehdr;
{
	register char	*p;

	for (p = header[typehdr].tag; *lp && *p; lp++, p++) {
		if (toupper(*p) != toupper(*lp))  {
			return(FALSE);
		}
	}
	if (*p == NULL) {
		return(TRUE);
	}
	return(FALSE);
}

/*
    NAME
	istext - check a line for text, non-text characters

    SYNOPSIS
	t_Content istext(unsigned char *line, int size, t_Content cur_content)

    DESCRIPTION
	istext() looks at the "size" characters within "line"
	for non-text characters. The definition of text
	characters when sending is based on the MTA spec and is
	specifically the 7-bit ASCII printable characters. Generic
	text characters are those which are printable according
	to the current locale.
	Printable text is defined by isprint(), white space (as defined by
	isspace()) and backspaces.

    RETURNS
	M_text - all characters are 7-bit ASCII
	M_gtext - all characters are text according to the current locale
	M_binary - at least one non-text character was found
*/

static const char is7bitprintable[] =
    {
    /* nul */ 0, /* soh */ 0, /* stx */ 0, /* etx */ 0, /* eot */ 0, /* enq */ 0, /* ack */ 0, /* bel */ 0,
    /* bs  */ 1, /* ht  */ 1, /* nl  */ 1, /* vt  */ 1, /* np  */ 1, /* cr  */ 1, /* so  */ 0, /* si  */ 0,
    /* dle */ 0, /* dc1 */ 0, /* dc2 */ 0, /* dc3 */ 0, /* dc4 */ 0, /* nak */ 0, /* syn */ 0, /* etb */ 0,
    /* can */ 0, /* em  */ 0, /* sub */ 0, /* esc */ 0, /* fs  */ 0, /* gs  */ 0, /* rs  */ 0, /* us  */ 0,
    /* sp  */ 1, /* !   */ 1, /* "   */ 1, /* #   */ 1, /* $   */ 1, /* %   */ 1, /* &   */ 1, /* '   */ 1,
    /* (   */ 1, /* )   */ 1, /* *   */ 1, /* +   */ 1, /* ,   */ 1, /* -   */ 1, /* .   */ 1, /* /   */ 1,
    /* 0   */ 1, /* 1   */ 1, /* 2   */ 1, /* 3   */ 1, /* 4   */ 1, /* 5   */ 1, /* 6   */ 1, /* 7   */ 1,
    /* 8   */ 1, /* 9   */ 1, /* :   */ 1, /* ;   */ 1, /* <   */ 1, /* =   */ 1, /* >   */ 1, /* ?   */ 1,
    /* @   */ 1, /* A   */ 1, /* B   */ 1, /* C   */ 1, /* D   */ 1, /* E   */ 1, /* F   */ 1, /* G   */ 1,
    /* H   */ 1, /* I   */ 1, /* J   */ 1, /* K   */ 1, /* L   */ 1, /* M   */ 1, /* N   */ 1, /* O   */ 1,
    /* P   */ 1, /* Q   */ 1, /* R   */ 1, /* S   */ 1, /* T   */ 1, /* U   */ 1, /* V   */ 1, /* W   */ 1,
    /* X   */ 1, /* Y   */ 1, /* Z   */ 1, /* [   */ 1, /* \   */ 1, /* ]   */ 1, /* ^   */ 1, /* _   */ 1,
    /* `   */ 1, /* a   */ 1, /* b   */ 1, /* c   */ 1, /* d   */ 1, /* e   */ 1, /* f   */ 1, /* g   */ 1,
    /* h   */ 1, /* i   */ 1, /* j   */ 1, /* k   */ 1, /* l   */ 1, /* m   */ 1, /* n   */ 1, /* o   */ 1,
    /* p   */ 1, /* q   */ 1, /* r   */ 1, /* s   */ 1, /* t   */ 1, /* u   */ 1, /* v   */ 1, /* w   */ 1,
    /* x   */ 1, /* y   */ 1, /* z   */ 1, /* {   */ 1, /* |   */ 1, /* }   */ 1, /* ~   */ 1, /* del */ 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x80 - 0x8F */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x90 - 0x9F */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xA0 - 0xAF */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xB0 - 0xBF */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xC0 - 0xCF */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xD0 - 0xDF */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xE0 - 0xEF */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  /* 0xF0 - 0xFF */
    };

#ifdef SVR4ES
#include <wctype.h>
#endif

t_Content istext(s, size, cur_content)
register unsigned char	*s;
int 		size;
t_Content	cur_content;
{
    register unsigned char *ep = s + size;
    register foundnontext;

    switch (cur_content)
	{
	case M_text:
	    /* Look for characters which aren't 7-bit ASCII printables. */
	    foundnontext = FALSE;
	    for (; s < ep; s++)
		{
		if (is7bitprintable[*s])
		    continue;
		foundnontext = TRUE;
		break;
		}
	    /* If any are found, then continue checking for non-generic-text printables */
	    if (!foundnontext)
		return M_text;
	    /* FALLTHROUGH */

#ifdef SVR4ES
#define GSS2 0x8E
#define GSS3 0x8F
#define GISASCII(c) (((c)&0x80) != 0)
	case M_gtext:
	    /* look for characters which aren't locale-specific printables */
	    while (s < ep)
		{
		register int c = *s;
		/* Code sets 1, 2 and 3 */
		if ((c == GSS2 || c == GSS3) || GISASCII(c))
		    {
		    /* Convert k bytes to a wide character. */
		    wchar_t w;
		    int k = mbtowc(&w, (char*)s, ep - s);
		    if (k == -1)
			return M_binary;
		    s += k;
		    /* Is our wide character printable? */
		    if (!(iswprint(w) || iswspace(w)))
			return M_binary;
		    }

		/* Code sets 0 */
		else
		    {
		    /* Is our byte printable? */
		    if (!(isprint(c) || isspace(c) || (c == '\b')))
			return M_binary;
		    s++;
		    }
		}

	    return M_gtext;
	    /* FALLTHROUGH */
#endif

	default:
	case M_binary:
	    return M_binary;
	}
}

/*
 * linecount (line, size) - determine the number of lines in a printable
 *                          file.
 */
int
linecount(lp, size)
	char	*lp;
	int 	size;
{
	register unsigned char	*line = (unsigned char*)lp;
	register unsigned char *ch;
	register int count = 0;

	for (ch = line+size; --ch >= line;)
		if (*ch == '\n')
			count++;
	return (count); 
}
