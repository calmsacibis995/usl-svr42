/*	Copyright (c) 1990, 1991, 1992 UNIX System Laboratories, Inc.	*/
/*	Copyright (c) 1984, 1985, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF     	*/
/*	UNIX System Laboratories, Inc.                     	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/* @(#)usr/src/common/uts/fs/vxfs/vx_param.h	1.5 28 Apr 1992 15:38:00 -  */
#ident	"@(#)uts-comm:fs/vxfs/vx_param.h	1.4"

/*
 * Copyright (c) 1991, 1992 VERITAS Software Corporation.  ALL RIGHTS RESERVED.
 * UNPUBLISHED -- RIGHTS RESERVED UNDER THE COPYRIGHT
 * LAWS OF THE UNITED STATES.  USE OF A COPYRIGHT NOTICE
 * IS PRECAUTIONARY ONLY AND DOES NOT IMPLY PUBLICATION
 * OR DISCLOSURE.
 * 
 * THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND
 * TRADE SECRETS OF VERITAS SOFTWARE.  USE, DISCLOSURE,
 * OR REPRODUCTION IS PROHIBITED WITHOUT THE PRIOR
 * EXPRESS WRITTEN PERMISSION OF VERITAS SOFTWARE.
 * 
 *               RESTRICTED RIGHTS LEGEND
 * USE, DUPLICATION, OR DISCLOSURE BY THE GOVERNMENT IS
 * SUBJECT TO RESTRICTIONS AS SET FORTH IN SUBPARAGRAPH
 * (C) (1) (ii) OF THE RIGHTS IN TECHNICAL DATA AND
 * COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013.
 *               VERITAS SOFTWARE
 * 4800 GREAT AMERICA PARKWAY, SUITE 420, SANTA CLARA, CA 95054
 */

#ifndef _FS_VXFS_VX_PARAM_H
#define _FS_VXFS_VX_PARAM_H

#ifdef _KERNEL_HEADERS

#ifndef _UTIL_PARAM_H
#include <util/param.h>	/* REQUIRED */
#endif

#elif defined(_KERNEL)

#include <sys/param.h>	/* REQUIRED */

#endif /* _KERNEL_HEADERS */

/*
 * Block size info
 */
#define	VX_MINBSIZE	1024	/* smallest block on any vxfs fs */
#define	VX_MINBOFFMASK	0x3ff	/* BOFFMASK for VX_MINBSIZE */
#define	VX_MINBSHIFT	10	/* BSHIFT for VX_MINBSIZE */
#define	VX_MAXBSIZE	8192	/* largest block on any vxfs fs */

#define IADDREXTSIZE	8192	/* indirect address extent size */
#define	NINDEXT		2048	/* num of addresses per indirect address ext */
#define	NINDEXTSHIFT	11	/* log 2 (NINDEXT) */

/*
 * The VX_ATOMIC_IOSZ is the unit of I/O which is guaranteed atomic.
 * This should be the smallest sector size of any device a file
 * system might reside on.  The VX_ATOMIC_IOSZ value is used to
 * break up log entries so no entry crosses an atomic I/O boundary.
 */

#define	VX_ATOMIC_IOSZ		512
#define	VX_ATOMIC_IOSHIFT	9

/*
 * The VX_MAX_DIO parameter is the maximum size of I/O operations issued
 * each time through the inner loop of the direct I/O code.  The VX_MAXIO
 * parameter is the largest I/O operation generated by the rest of the
 * file system.  Both must be a multiple of VX_MAXBSIZE.
 */

#define	VX_MAXIO	(64 * 1024)
#define	VX_MAX_DIO	(128 * 1024)

/*
 * When getpage is called, this is the maximum number of pages it will
 * obtain in one call.
 */

#define	VX_MAXGETPAGES		16

/*
 * When sequential asynchronous writes are issued to a file the default
 * write code will do an asynchronous flush behind every vx_prefio
 * bytes.  In low memory conditions, a synchronous flush behind is issued
 * at VX_MAXDIRTY behind the current write point.  This limits a file to
 * VX_MAXDIRTY bytes worth of dirty pages when memory is low.
 *
 * The VX_MAXDISKQ is used to limit flushing.  Building up a large disk
 * queue on one file can delay accesses for other files.  By limiting the
 * disk queue, we can maintain enough outstanding I/O to get maximum
 * streaming performance, while not blocking other accesses for long
 * periods of time.
 */

#define	VX_MAXDIRTY		(128 * 1024)
#define	VX_MAXDISKQ		(256 * 1024)

/*
 * Delayed extending writes are flushed every VX_DFLUSH_TIME seconds.  We
 * use the fsflush process to flush when it calls vx_putpage.  If it doesn't
 * flush within 2*VX_DFLUSH_TIME seconds, then we do it the next time
 * a process is leaving the file system code in the VX_INACTIVE1 macro.
 */

#define	VX_DFLUSH_TIME		5

/*
 * The maximum number of transactions desired on a file system at any one time.
 */

#define	VX_REPLAY_LOW		250
#define	VX_REPLAY_MED		350

/*
 * Flags for internal putpage calls.  If VX_PUTNOWAIT is set, then we can
 * call the fast routines to just flush unlocked pages.
 */

#define	VX_PUTWAIT		1
#define	VX_PUTNOWAIT		2

/*
 * To balance file system usage, when the file system free space falls
 * below VX_MINFREE we will stop allocating very large extents.  When
 * an allocation unit falls below VX_AUFREE[i] blocks free we will start
 * allocating inodes into other allocation units with VX_AUFREE[i+1] blocks.
 */

#define	VX_MINFREE	10	/* minimum pct of fs that we want free */
#define	VX_AUFREE1	5
#define	VX_AUFREE2	10
#define	VX_AUFREE3	20
#define	VX_AUFREE4	30

/*
 * This controls the maximum number of inodes that may cluster as a
 * side inode update in vx_iupdat().  Ordinarily its as many inodes
 * as fit in a block.
 */

#define	VX_MAXICLUSTER	(VX_MAXBSIZE / sizeof (struct inode))

/*
 * This controls the maximum number of snapshot file systems that can
 * be mounted simultaneously.  It is the number of minor device numbers
 * that will be allocated by the vx_dev_alloc() routine.
 */

#define	VX_DEV_MAXMINOR	256

/*
 * These values define the maximum and minimum log buffer sizes.
 */

#define	VX_MAXLOGBUF	65536
#define	VX_MINLOGBUF	16384

#endif  /* _FS_VXFS_VX_PARAM_H */
